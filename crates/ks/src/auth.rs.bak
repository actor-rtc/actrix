//! KS 服务认证模块 - 使用 nonce-auth 库进行 PSK 签名验证和防重放攻击保护

use crate::error::{KsError, KsResult};
use base::storage::nonce::SqliteNonceStorage;
use nonce_auth::{NonceServer, NonceClient, NonceCredential};
use std::sync::Arc;
use std::time::Duration;
use tracing::debug;

/// PSK 认证器
/// 
/// 使用 nonce-auth 库提供 PSK 签名验证和防重放攻击保护
#[derive(Clone)]
pub struct PskAuthenticator {
    /// nonce-auth 服务器
    server: Arc<NonceServer<SqliteNonceStorage>>,
    /// 预共享密钥（用于创建客户端）
    psk: String,
}

impl PskAuthenticator {
    /// 创建新的 PSK 认证器
    pub async fn new(psk: String, database_path: &str) -> KsResult<Self> {
        let nonce_storage = SqliteNonceStorage::new(Some(database_path.to_string()))
            .map_err(|e| KsError::Internal(format!("Failed to create nonce storage: {e}")))?;

        let storage = Arc::new(nonce_storage);
        
        // 使用 builder pattern 创建 NonceServer，时间容忍度 5 分钟，nonce TTL 10 分钟
        let server = NonceServer::builder()
            .with_storage(storage)
            .with_time_window(Duration::from_secs(300)) // 5 分钟时间容忍度
            .with_ttl(Duration::from_secs(600)) // 10 分钟 nonce TTL
            .build_and_init()
            .await
            .map_err(|e| KsError::Internal(format!("Failed to create nonce server: {e}")))?;

        Ok(Self {
            server: Arc::new(server),
            psk,
        })
    }

    /// 验证凭证（使用 nonce-auth 库）
    /// 
    /// # Arguments
    /// * `credential` - nonce-auth 的 NonceCredential
    /// * `request_data` - 需要验证的请求数据
    pub async fn verify_credential(
        &self,
        credential: &NonceCredential,
        request_data: &str,
    ) -> KsResult<()> {
        self.server
            .credential_verifier(credential)
            .with_secret(self.psk.as_bytes())
            .verify(request_data.as_bytes())
            .await
            .map_err(|e| match e {
                nonce_auth::NonceError::DuplicateNonce => {
                    KsError::ReplayAttack("Nonce already used".to_string())
                }
                nonce_auth::NonceError::TimestampOutOfWindow => {
                    KsError::Authentication("Request timestamp out of range".to_string())
                }
                nonce_auth::NonceError::InvalidSignature => {
                    KsError::Authentication("Invalid signature".to_string())
                }
                _ => KsError::Internal(format!("Authentication error: {e}")),
            })?;

        debug!("Request authentication successful");
        Ok(())
    }

    /// 清理过期的 nonce 记录
    pub async fn cleanup_expired_nonces(&self) -> KsResult<()> {
        // 使用默认的 TTL 进行清理
        let ttl = Duration::from_secs(600); // 10 分钟
        
        // 通过服务器实例清理过期的 nonce
        let deleted_count = self.server
            .cleanup_expired_nonces(ttl)
            .await
            .map_err(|e| KsError::Internal(format!("Nonce cleanup error: {e}")))?;

        debug!("Cleaned up {} expired nonces with TTL: {:?}", deleted_count, ttl);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    async fn create_test_authenticator() -> (PskAuthenticator, tempfile::TempDir) {
        let temp_dir = tempdir().unwrap();
        let db_path = temp_dir.path().join("test_nonces.db");
        let auth = PskAuthenticator::new("test-psk".to_string(), db_path.to_str().unwrap()).await.unwrap();
        (auth, temp_dir)
    }

    #[tokio::test]
    async fn test_credential_generation_and_verification() {
        let (auth, _temp_dir) = create_test_authenticator().await;
        let request_data = "test-request-data";
        
        // 生成凭证
        let credential = auth.create_credential(request_data).unwrap();
        
        // 验证凭证
        let result = auth.verify_credential(&credential, request_data).await;
        if let Err(e) = &result {
            eprintln!("Verification error: {:?}", e);
        }
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_invalid_signature() {
        let (auth, _temp_dir) = create_test_authenticator().await;
        let request_data = "test-request-data";
        
        // 生成凭证
        let credential = auth.create_credential(request_data).unwrap();
        
        // 修改签名使其无效（这需要访问内部字段，可能需要调整）
        // 为简化，我们使用不同的请求数据来测试无效验证
        let wrong_data = "wrong-request-data";
        
        let result = auth.verify_credential(&credential, wrong_data).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), KsError::Authentication(_)));
    }

    #[tokio::test]
    async fn test_nonce_replay_protection() {
        let (auth, _temp_dir) = create_test_authenticator().await;
        let request_data = "test-request-data";
        
        // 生成凭证
        let credential = auth.create_credential(request_data).unwrap();
        
        // 首次请求应该成功
        let result1 = auth.verify_credential(&credential, request_data).await;
        if let Err(e) = &result1 {
            eprintln!("First verification error: {:?}", e);
        }
        assert!(result1.is_ok());
        
        // 重复使用相同凭证应该失败（重放攻击）
        let result2 = auth.verify_credential(&credential, request_data).await;
        assert!(result2.is_err());
        assert!(matches!(result2.unwrap_err(), KsError::ReplayAttack(_)));
    }

    #[tokio::test]
    async fn test_cleanup_expired_nonces() {
        let (auth, _temp_dir) = create_test_authenticator().await;
        let result = auth.cleanup_expired_nonces().await;
        assert!(result.is_ok());
    }
}