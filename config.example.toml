# Actrix Configuration Example
#
# Service enable bitmask (binary representation):
#   xxxxx
#   ││││└─ Signaling (00001 = 1)
#   │││└── STUN      (00010 = 2)
#   ││└─── TURN      (00100 = 4)
#   │└──── AIS       (01000 = 8)
#   └───── KS        (10000 = 16)
#
# All services are controlled by this bitmask. No individual enabled fields are needed.
#
# Examples:
#   31 (0b11111) = All services (1+2+4+8+16)
#   22 (0b10110) = KS + TURN + STUN (16+4+2)
#   6  (0b00110) = TURN + STUN (4+2)
#   4  (0b00100) = TURN only
#   2  (0b00010) = STUN only
#   1  (0b00001) = Signaling only
#   8  (0b01000) = AIS only
#   16 (0b10000) = KS only
enable = 6

# Instance identifier (used for monitoring and tracing)
name = "actrix-01"

# Environment: dev/prod/test
# - dev: allows HTTP, relaxed security
# - prod: enforces HTTPS, strict security
# - test: for automated testing
env = "dev"

# SQLite database storage directory path
# Main database file will be stored as {sqlite_path}/actrix.db
sqlite_path = "database"

# Geographic location tag (for multi-region deployment monitoring)
# Format: cloud-provider,region,zone
# Examples: "aws,us-west-2,zone-a", "aliyun,beijing,zone-b"
location_tag = "local,dev,default"

# Shared PSK for inter-service authentication
# IMPORTANT: Change this in production!
# Generate a strong key: openssl rand -hex 32
actrix_shared_key = "example-key-please-replace-with-secure-random-value-32chars+"

# Observability (logging + tracing)
[observability]
# Unified filter for logs and tracing (EnvFilter syntax)
# If RUST_LOG is set, it overrides this value.
filter_level = "info"

[observability.log]
# Log output destination: console/file
# - console: Output to stdout (default, recommended for development)
# - file: Output to log files (recommended for production)
output = "console"

# Log rotation (only applies when output = "file")
# - true: Create new log file daily (actrix-2024-01-15.log, actrix-2024-01-16.log, etc.)
# - false: Append to single file (actrix.log)
rotate = false

# Log file directory (only applies when output = "file")
# All log files will be stored in this directory
path = "logs/"

# ============================================================================
# OpenTelemetry Distributed Tracing Configuration (requires opentelemetry feature)
# ============================================================================
[observability.tracing]
# Enable tracing export to OTLP backend
# To use this, compile with: cargo build --features opentelemetry
enable = false

# Service name for tracing (appears in Jaeger UI)
service_name = "actrix"

# OTLP gRPC endpoint
# Examples:
#   - Jaeger (docker): http://127.0.0.1:4317
#   - Grafana Tempo: http://tempo:4317
#   - OpenTelemetry Collector: http://otel-collector:4317
endpoint = "http://127.0.0.1:4317"

# Process management (optional)
# pid = "/var/run/actrix.pid"  # (optional)
# user = "actrix"  # (optional) Drop privileges to this user after binding ports
# group = "actrix"  # (optional) Drop privileges to this group

# ============================================================================
# Network Binding Configuration
# ============================================================================

[bind]
# HTTP (development only - NOT recommended for production)
[bind.http]
domain_name = "localhost"
advertised_ip = "127.0.0.1"
ip = "127.0.0.1"
port = 8080

# HTTPS (required for production)
[bind.https]
domain_name = "actrix.example.com"
advertised_ip = "203.0.113.10"
ip = "0.0.0.0"
port = 8443
cert = "certificates/server.crt"
key = "certificates/server.key"

# ICE services (STUN/TURN)
[bind.ice]
domain_name = "ice.example.com"
advertised_ip = "203.0.113.10"
ip = "0.0.0.0"
port = 3478

# ============================================================================
# TURN Configuration
# ============================================================================
[turn]
# Server advertised IP (must be routable)
# Replace with your actual public IP
advertised_ip = "203.0.113.10"

# Advertised port for TURN
advertised_port = 3478

# Relay port range for TURN data channels
# Format: start-end (e.g., "49152-65535")
# Larger range = more concurrent relay sessions
relay_port_range = "49152-65535"

# TURN realm
realm = "actrix.example.com"

# ============================================================================
# Service Configuration (optional)
# ============================================================================
# All HTTP services share the instance-level HTTP/HTTPS port (bind.http/bind.https)
#
# Key Server (KS) Configuration (optional)
# Service enablement is controlled by the bitmask (enable field)
# Set ENABLE_KS bit (16) in the enable field to enable this service
[services.ks]

[services.ks.storage]
backend = "sqlite"
key_ttl_seconds = 3600

[services.ks.storage.sqlite]
path = "ks.db"

# AIS (Actor Identity Service) Configuration (optional)
# Service enablement is controlled by the bitmask (enable field)
# Set ENABLE_AIS bit (8) in the enable field to enable this service
[services.ais]

[services.ais.server]
# signaling_heartbeat_interval_secs = 30  # (optional, default: 30)
# token_ttl_secs = 3600  # (optional, default: 3600)

# AIS automatically uses local KS if enabled, or configure explicitly (optional):
# [services.ais.dependencies.ks]
# endpoint = "http://remote-ks:50052"  # gRPC endpoint

# Signaling Service Configuration (optional)
# Service enablement is controlled by the bitmask (enable field)
# Set ENABLE_SIGNALING bit (1) in the enable field to enable this service
[services.signaling]

[services.signaling.server]
ws_path = "/signaling"

# Rate limiting configuration (optional, all have defaults)
# [services.signaling.server.rate_limit.connection]
# enabled = true  # (optional, default: true)
# per_minute = 5  # (optional, default: 5)
# burst_size = 10  # (optional, default: 10)
# max_concurrent_per_ip = 100  # (optional, default: 100)
#
# [services.signaling.server.rate_limit.message]
# enabled = true  # (optional, default: true)
# per_second = 10  # (optional, default: 10)
# burst_size = 50  # (optional, default: 50)

# Signaling dependencies (optional, auto-discovered if local services enabled)
# [services.signaling.dependencies.ks]
# endpoint = "http://remote-ks:50052"  # (optional)
#
# [services.signaling.dependencies.ais]
# endpoint = "http://remote-ais:8080"  # (optional)

# ============================================================================
# Supervisor Platform Integration (optional)
# ============================================================================
# Enable Supervisor platform integration by configuring the [supervisor] section.
# This enables both:
#   - Supervisord gRPC service (listens on ip:port, implements SupervisedService)
#   - Supervisor client (connects to endpoint, registers node and reports status)
#
[supervisor]
# Connection timeout in seconds (optional, default: 30)
connect_timeout_secs = 30

# Status report interval in seconds (optional, default: 60)
# How often to send status reports to Supervisor
status_report_interval_secs = 60

# Health check interval in seconds (optional, default: 30)
# How often to perform health checks with Supervisor
health_check_interval_secs = 30

# Enable TLS for connections to Supervisor (optional, default: false)
enable_tls = false

# TLS domain for certificate verification (required when enable_tls is true)
# Must match the certificate's Common Name (CN) or Subject Alternative Name (SAN)
# tls_domain = "supervisor.example.com"  # (required if enable_tls = true)

# Client certificate path for mTLS (optional)
# If provided, both client_cert and client_key must be set
# client_cert = "/path/to/client-cert.pem"  # (optional)

# Client private key path for mTLS (optional)
# Must be provided together with client_cert
# client_key = "/path/to/client-key.pem"  # (optional)

# CA certificate path for server certificate verification (optional)
# If not provided, system default CAs are used
# ca_cert = "/path/to/ca-cert.pem"  # (optional)

# Maximum allowed clock skew in seconds (optional, default: 300)
# Used for nonce-auth timestamp validation
max_clock_skew_secs = 300

[supervisor.supervisord]
# Optional human readable node name
node_name = "actrix-edge-01"

# Supervisord gRPC bind IP address (optional, default: "0.0.0.0")
# Network interface IP address to bind the supervisord gRPC service
ip = "0.0.0.0"

# Supervisord gRPC bind port (optional, default: 50055)
# Port number for the supervisord gRPC service to listen on
port = 50055

# Supervisord gRPC advertised IP address (optional, default: "127.0.0.1")
# Public IP address that Supervisor will use to connect back to this node
# In NAT environments, this is typically the router's public IP
advertised_ip = "127.0.0.1"

[supervisor.client]
# Copy these values from Supervisor management platform after creating a node
# Node unique identifier (required)
# Must be unique within the Supervisor platform
node_id = "actrix-node-01"

# Optional display name (defaults to node_id if omitted)
# name = "actrix-edge-01"  # (optional)

# Shared secret for nonce-auth authentication (required)
# Hex-encoded, must be at least 64 hex characters (32 bytes)
shared_secret = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

# Supervisor gRPC server endpoint (required)
# Format: http://hostname:port or https://hostname:port
endpoint = "http://supervisor.example.com:50051"

# ============================================================================
# Production Configuration Example
# ============================================================================
# This section demonstrates a production-ready configuration.
# Copy and modify these settings for production deployment.
#
# Key differences from development:
# - env = "prod"
# - observability.log.output = "file" with rotate = true
# - HTTPS with valid certificates
# - Real public IP for TURN
# - OpenTelemetry enabled with production endpoint
# - Strong actrix_shared_key
#
# Example production config:
#
# enable = 22
# name = "actrix-prod-01"
# env = "prod"
# [observability]
# filter_level = "info"
# 
# [observability.log]
# output = "file"
# rotate = true
# path = "/var/log/actrix/"
# 
# sqlite_path = "/var/lib/actrix"
# location_tag = "aws,us-west-2,zone-a"
# actrix_shared_key = "REPLACE_WITH_STRONG_RANDOM_KEY_MINIMUM_32_CHARS"
# pid = "/var/run/actrix.pid"
# user = "actrix"
# group = "actrix"
#
# [observability.tracing]
# enable = true
# service_name = "actrix-prod-01"
# endpoint = "http://otel-collector.internal:4317"
#
# [bind.https]
# domain_name = "actrix.example.com"
# ip = "0.0.0.0"
# port = 443
# cert = "/etc/actrix/tls/fullchain.pem"
# key = "/etc/actrix/tls/privkey.pem"
#
# [bind.ice]
# domain_name = "ice.example.com"
# ip = "0.0.0.0"
# port = 3478
#
# [turn]
# advertised_ip = "203.0.113.10"  # Your actual public IP
# advertised_port = 3478
# relay_port_range = "49152-65535"
# realm = "actrix.example.com"

# ACL (Access Control List) Configuration
[acl]
# Enable ACL enforcement for Presence, Discovery, and Relay
# When enabled, ACL checks are performed for:
# - Presence notifications (ActrUpEvent)
# - Service discovery (DiscoveryRequest)
# - WebRTC relay (ActrRelay)
enabled = true

# Default policy when no ACL rule exists
# - "deny": Deny discovery/relay if no ACL rule found (recommended, secure by default)
# - "allow": Allow discovery/relay if no ACL rule found (insecure, use only for testing)
default_policy = "deny"

# Note: ACL rules are stored in SQLite database (actoracl table)
# Example rules (inserted via SQL or application API):
# INSERT INTO actoracl (tenant_id, from_type, to_type, access) VALUES ('tenant1', 'user', 'service', 1);
# INSERT INTO actoracl (tenant_id, from_type, to_type, access) VALUES ('tenant1', 'anonymous', 'admin', 0);
